include: "common.smk"

localrules: calc_exon_ratios, count_bases_exon, count_bases_gene

rule all:
    input:
        base_per_exon=expand("{sample}/expression/{sample}.bases_per_exon", sample=samples),
        base_per_gene=expand("{sample}/expression/{sample}.bases_per_gene", sample=samples),
        exon_ratio=expand("{sample}/expression/{sample}.exon_ratios", sample=samples),
        fragment_per_gene=expand("{sample}/expression/{sample}.fragments_per_gene", sample=samples),
        raw_base=expand("{sample}/expression/{sample}.raw_base", sample=samples),

rule idsort_aln:
    input:
        bam=get_bamfile,
    output:
        bam=temp("{sample}/snv-indels/{sample}.snv-indel.idsorted.bam"),
    params:
        tmp=temp("tmp"),
    log:
        "log/idsort_aln.{sample}.txt"
    threads: 1
    container: containers["picard"]
    shell:
        "picard -Xmx4G SortSam I={input.bam} O={output.bam} SORT_ORDER=queryname"
        " VALIDATION_STRINGENCY=SILENT CREATE_INDEX=false TMP_DIR={params.tmp} 2> {log}"

rule count_fragments:
    input:
        bam="{sample}/snv-indels/{sample}.snv-indel.idsorted.bam",
        gtf=config["expression_gtf"],
    output:
        fragments_per_gene="{sample}/expression/{sample}.fragments_per_gene",
    log:
        "log/count_fragments.{sample}.txt"
    threads: 1
    container: containers["htseq"]
    shell:
        "htseq-count --format bam --order name --stranded no"
        " {input.bam} {input.gtf} > {output.fragments_per_gene} 2> {log}"

rule count_raw_bases:
    input:
        bam=get_bamfile,
        bed=config["expression_bed"],
        count_script=config["base_count_script"],
    output:
        raw_base_count="{sample}/expression/{sample}.raw_base",
    log:
        "log/count_raw_bases.{sample}.txt"
    threads: 1
    container: containers["bedtools-2.17-python-2.7"]
    shell:
        "bedtools coverage -split -hist -abam {input.bam} -b {input.bed}"
        " 2> {log} | python {input.count_script} -c 3 > {output.raw_base_count}"

rule count_bases_exon:
    input:
        raw="{sample}/expression/{sample}.raw_base",
        aggr_script=config["aggr_base_count_script"],
    output:
        bases_per_exon="{sample}/expression/{sample}.bases_per_exon",
    params:
        sample=lambda wildcards: wildcards.sample,
    log:
        "log/count_bases_exon.{sample}.txt"
    threads: 1
    container: containers["hamlet-scripts"]
    shell:
        "Rscript {input.aggr_script} -I {input.raw} -N {params.sample}"
        " -E {output.bases_per_exon} 2> {log}"

rule count_bases_gene:
    input:
        raw="{sample}/expression/{sample}.raw_base",
        aggr_script=config["aggr_base_count_script"],
    output:
        bases_per_gene="{sample}/expression/{sample}.bases_per_gene",
    params:
        sample=lambda wildcards: wildcards.sample,
    log:
        "log/count_bases_gene.{sample}.txt"
    threads: 1
    container: containers["hamlet-scripts"]
    shell:
        "Rscript {input.aggr_script} -I {input.raw} -N {params.sample}"
        " -G {output.bases_per_gene} 2> {log}"

rule calc_exon_ratios:
    input:
        table="{sample}/expression/{sample}.bases_per_exon",
        calc_script=config["calc_ratio_script"],
    output:
        table="{sample}/expression/{sample}.exon_ratios",
    params:
        exon_ratio_names=" ".join(
            [config["relative_gene_name"]] + config.get("exon_names")
        ),
        exon_min_ratio=config["exon_min_ratio"],
    log:
        "log/calc_exon_ratios.{sample}.txt"
    threads: 1
    container: containers["hamlet-scripts"]
    shell:
        "cat {input.table}"
        " | python3 {input.calc_script} -r {params.exon_min_ratio}"
        " - {params.exon_ratio_names}"
        " > {output.table} 2> {log}"
